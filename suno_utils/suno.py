#!/usr/bin/env python3
"""
suno_hackmit.py
Simple helper to generate a song via the Suno HackMIT API and poll for results.

Usage:
    export SUNO_API_KEY="your_token_here"
    python suno_hackmit.py "An upbeat pop song about coding at HackMIT"

If no prompt is provided on the command line, a default prompt will be used.
"""

from __future__ import annotations
import os, sys, time, json, dotenv
from typing import Optional, Dict, Any, Literal
import requests
from stream_audio import MediaPlayer

from dataclasses import dataclass

dotenv.load_dotenv()

BASE_URL = "https://studio-api.prod.suno.com/api/v2/external/hackmit"
GENERATE_ENDPOINT = f"{BASE_URL}/generate"
CLIPS_ENDPOINT = f"{BASE_URL}/clips"


class SunoAPIError(Exception):
    pass

@dataclass
class StatusCheck:
    status: Literal['submitted', 'streaming', 'complete']
    audio_url: str
    cover_img_url: str
    song_length: float

def await_check_status(
    clip_id: str = None,
    api_key: str = None,
    poll_interval: float = 5.0,
    poll_timeout: float = 180.0,
) -> StatusCheck:

    if clip_id is None:
        raise Exception('clip_id is None')

    api_key = os.getenv('SUNO_API_KEY')

    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
    }

    session = requests.Session()
    session.headers.update(headers)

    # 2) Poll /clips for status
    start = time.time()
    deadline = start + poll_timeout
    attempt = 0
    while True:
        attempt += 1
        try:
            q = {"ids": clip_id}
            poll_resp = session.get(CLIPS_ENDPOINT, params=q, timeout=20)
        except requests.RequestException as e:
            # transient network failure — backoff and retry, as long as we haven't timed out
            if time.time() >= deadline:
                raise SunoAPIError(f"Polling failed and timed out: {e}")
            time.sleep(min(5 * attempt, poll_interval))
            continue

        if poll_resp.status_code == 401:
            raise SunoAPIError("Polling 401 Unauthorized: check YOUR token.")
        if poll_resp.status_code == 403:
            raise SunoAPIError("Polling 403 Forbidden: your token lacks access.")
        if poll_resp.status_code == 429:
            # Rate limited — wait longer, then retry
            retry_after = poll_resp.headers.get("Retry-After")
            wait = int(retry_after) if retry_after and retry_after.isdigit() else max(10, poll_interval)
            if time.time() + wait > deadline:
                raise SunoAPIError("Polling rate-limited and would exceed timeout.")
            time.sleep(wait)
            continue
        if poll_resp.status_code >= 400:
            # other client/server error
            try:
                err = poll_resp.json()
            except Exception:
                err = poll_resp.text
            raise SunoAPIError(f"Error polling clips ({poll_resp.status_code}): {err}")

        try:
            clips_array = poll_resp.json()
        except Exception:
            raise SunoAPIError("Failed to parse /clips response as JSON.")

        if not isinstance(clips_array, list) or len(clips_array) == 0:
            # API returns an array — if empty, keep polling until timeout
            if time.time() >= deadline:
                raise SunoAPIError("No clip data returned and polling timed out.")
            time.sleep(poll_interval)
            continue

        clip = clips_array[0]
        status = clip.get("status", "").lower()
        # Return if streaming or complete
        if status in ("complete"):
            return StatusCheck(
                status=status,
                audio_url=clip.get('audio_url'),
                cover_img_url=clip.get('image_url'),
                song_length=clip['metadata']['duration'],
            )  

        # If error
        if status == "error":
            md = clip.get("metadata", {}) or {}
            raise SunoAPIError(f"Clip generation failed: {md.get('error_type')} - {md.get('error_message')}")

        # Not ready yet: respect poll_interval and timeout
        if time.time() >= deadline:
            raise SunoAPIError(f"Timed out waiting for clip to stream/complete (timeout {poll_timeout}s). Last status: {status}")

        # Otherwise wait and try again
        time.sleep(poll_interval)

# Generated by chatgpt
def generate_song(
    topic: Optional[str] = None,
    tags: Optional[str] = None,
    make_instrumental: Optional[bool] = True,
) -> str:
    api_key = os.environ.get("SUNO_API_KEY")

    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
    }

    payload: Dict[str, Any] = {}
    # The docs show either topic (simple mode) or prompt (custom mode).
    elif topic:
        payload["topic"] = topic
    else:
        raise ValueError("Either 'prompt' or 'topic' must be provided.")

    if tags:
        payload["tags"] = tags

    # Turn off lyric
    payload['make_instrumental'] = make_instrumental

    session = requests.Session()
    session.headers.update(headers)

    # 1) Submit generation
    try:
        resp = session.post(GENERATE_ENDPOINT, json=payload, timeout=30)
    except requests.RequestException as e:
        raise SunoAPIError(f"Failed to submit generate request: {e}")

    if resp.status_code == 401:
        raise SunoAPIError("401 Unauthorized: check your SUNO_API_KEY.")
    if resp.status_code == 403:
        raise SunoAPIError("403 Forbidden: you may not be a HackMIT participant or key invalid.")
    if resp.status_code >= 400:
        # Try to show server error details if present
        try:
            detail = resp.json()
        except Exception:
            detail = resp.text
        raise SunoAPIError(f"Generation request failed ({resp.status_code}): {detail}")

    try:
        clip_obj = resp.json()
    except Exception:
        raise SunoAPIError("Failed to parse generation response as JSON.")

    clip_id = clip_obj.get("id")
    if not clip_id:
        raise SunoAPIError(f"No clip id returned in generation response: {clip_obj!r}")

    return clip_id

# def _pretty_print_clip(clip: Dict[str, Any]) -> None:
#     print("=== Clip result ===")
#     print(f"id: {clip.get('id')}")
#     print(f"status: {clip.get('status')}")
#     print(f"title: {clip.get('title')}")
#     print(f"audio_url: {clip.get('audio_url')}")
#     print(f"image_url: {clip.get('image_url')}")
#     md = clip.get("metadata") or {}
#     duration = md.get("duration")
#     if duration is not None:
#         print(f"duration (s): {duration}")
#     # Print the prompt/tags if present
#     if md.get("prompt"):
#         print("prompt (snippet):")
#         print(md.get("prompt")[:400])
#     if md.get("tags"):
#         print(f"tags: {md.get('tags')}")
#     print("===================")


if __name__ == "__main__":
    print('Here')
    # Simple CLI for testing the function
    api_key = os.environ.get("SUNO_API_KEY")
    if not api_key:
        print("ERROR: SUNO_API_KEY environment variable not set.", file=sys.stderr)
        sys.exit(2)

    # Accept prompt from argv or use a default topic
    if len(sys.argv) > 1:
        user_input = " ".join(sys.argv[1:])
        # If the user passes a prompt with newline-style markers, we will assume it's custom lyrics.
        prompt = user_input
        topic = None
    else:
        # Default: use a short topic (simple mode)
        prompt = None
        topic = "An upbeat pop song about coding at HackMIT"

    try:

        print('Starting Generation...')

        clip_id = generate_song(
            topic=topic,
            tags="pop, electronic, upbeat, energetic",
        )

        print('Awaiting...')

        clip_result = await_check_status(
            clip_id=clip_id,
            poll_interval=5.0,
            poll_timeout=180.0,
        )

        print('Clip loaded...')

    except SunoAPIError as e:
        print(f"Generation failed: {e}", file=sys.stderr)
        sys.exit(1)

    # For debugging
    # _pretty_print_clip(clip_result)
    # Optionally write metadata and clip JSON to a file for later review
    # outfn = f"suno_clip_{clip_result.get('id')}.json"
    # try:
    #     with open(outfn, "w", encoding="utf-8") as f:
    #         json.dump(clip_result, f, indent=2, ensure_ascii=False)
    #     print(f"Wrote clip metadata to {outfn}")
    # except Exception as e:
    #     print(f"Warning: failed to write clip JSON: {e}", file=sys.stderr)

    # If audio_url is present and status is "complete", you can download it:
    if not clip_result.audio_url:
        raise Exception('audio_url blank')

    print(clip_result.song_length)

    p = MediaPlayer(clip_result.audio_url)

    p.play()

    while p.is_playing():

        time.sleep(1)
